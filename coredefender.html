<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Core Defender - Touch</title>
    <style>
        body {
            background-color: #111;
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Center vertically */
            min-height: 100vh; /* Ensure full height */
            margin: 0;
            font-family: 'Courier New', Courier, monospace; /* Retro font */
            overflow: hidden; /* Prevent scrollbars */
            /* Prevent text selection on touch controls */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            /* Prevent callout menu on long press */
            -webkit-touch-callout: none;
        }

        h1 {
             margin-bottom: 10px; /* Add some space below title */
        }

        #game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }


        #game-container {
            border: 2px solid #0f0; /* Green border like old monitors */
            position: relative; /* For positioning HUD and Management Screen */
            background-color: #000;
            box-shadow: 0 0 15px #0f0; /* Glow effect */
            /* Ensure canvas size matches CSS */
            width: 600px;
            height: 400px;
            max-width: 95vw; /* Limit width on smaller screens */
            /* Calculate height based on aspect ratio */
            aspect-ratio: 600 / 400;
            height: auto; /* Let aspect ratio determine height */
        }

        #game-canvas {
            display: block; /* Remove extra space below canvas */
            width: 100%;
            height: 100%;
        }

        #management-screen {
            display: none; /* Hidden initially */
            width: 100%; /* Take full width of container */
            height: 100%; /* Take full height of container */
            background-color: rgba(0, 0, 0, 0.95); /* Slightly transparent black */
            border: 1px solid #0f0;
            padding: 15px;
            box-sizing: border-box;
            color: #0f0; /* Green text */
            font-size: 14px;
            line-height: 1.5;
            position: absolute; /* Position over canvas */
            top: 0;
            left: 0;
            overflow-y: auto; /* Add scroll if needed */
            z-index: 20; /* Ensure it's above canvas and HUD */
        }

        #management-screen h2 {
            text-align: center;
            margin-top: 0;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: flicker 1.5s infinite alternate; /* Flicker effect */
        }

        @keyframes flicker {
          0%, 18%, 22%, 25%, 53%, 57%, 100% { text-shadow: 0 0 4px #0f0, 0 0 11px #0f0, 0 0 19px #0f0, 0 0 40px #0f0, 0 0 80px #0f0, 0 0 90px #0f0, 0 0 100px #0f0, 0 0 150px #0f0; opacity: 1; }
          20%, 24%, 55% { text-shadow: none; opacity: 0.8; }
        }


        #management-screen .status-readout {
            display: flex;
            justify-content: space-around;
            margin-bottom: 10px;
            border-bottom: 1px dashed #0f0;
            padding-bottom: 5px;
        }
         #management-screen .status-readout span {
             min-width: 100px;
             text-align: center;
         }


        #management-screen .control-group {
             margin-bottom: 8px; /* Reduced margin */
             display: flex; /* Use flexbox for alignment */
             align-items: center; /* Center items vertically */
             flex-wrap: wrap; /* Allow wrapping on small screens if needed */
         }

        #management-screen label {
            /* display: inline-block; */ /* Replaced by flex */
            width: 80px; /* Fixed width for labels */
            margin-bottom: 3px;
            flex-shrink: 0; /* Prevent label from shrinking */
        }

        #management-screen input[type="range"] {
            /* width: calc(70% - 40px); */ /* Replaced by flex */
            flex-grow: 1; /* Allow slider to take remaining space */
            margin-bottom: 5px;
            /* vertical-align: middle; */ /* Replaced by flex align-items */
            accent-color: #0f0; /* Make slider green */
            outline: none; /* Remove default focus outline */
            min-width: 100px; /* Ensure slider doesn't get too small */
            margin-left: 5px;
            margin-right: 5px;
        }

        #management-screen .power-value {
            font-weight: bold;
            min-width: 35px; /* Ensure alignment */
            /* display: inline-block; */ /* Replaced by flex */
            text-align: right;
             margin-left: 5px;
             /* vertical-align: middle; */ /* Replaced by flex align-items */
             flex-shrink: 0; /* Prevent value from shrinking */
        }

        #management-screen button {
            display: block;
            margin: 10px auto 0; /* Reduced margin */
            padding: 8px 15px;
            background-color: #0f0;
            color: #000;
            border: none;
            font-family: inherit;
            font-size: 14px;
            cursor: pointer; /* Keep pointer for mouse users */
            text-transform: uppercase;
            transition: background-color 0.2s, color 0.2s;
            outline: none; /* Remove default focus outline */
        }

        #management-screen button:hover {
            background-color: #000;
            color: #0f0;
            outline: 1px solid #0f0;
        }
        #management-screen button:disabled {
             background-color: #555;
             color: #999;
             cursor: not-allowed;
             outline: none;
        }
        #management-screen button:disabled:hover {
            background-color: #555;
            color: #999;
            outline: none;
        }


        /* Style for the currently focused control in Management Screen */
        .focused-control {
             outline: 2px solid #ff0 !important; /* Yellow outline for focus */
             box-shadow: 0 0 10px #ff0;
        }


        #hud {
            position: absolute;
            top: 5px; /* Adjusted slightly */
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            color: #0f0; /* Green HUD text */
            font-size: clamp(12px, 2.5vw, 16px); /* Responsive font size */
            pointer-events: none; /* Allow clicks through HUD */
            text-shadow: 0 0 5px #0f0;
            z-index: 10; /* Ensure HUD is above canvas */
        }
         #hud .hud-group {
             display: flex;
             gap: 15px; /* Space between items */
         }


         /* Blinking cursor effect for management screen */
        .cursor::after {
            content: '_';
            opacity: 0;
            animation: blink 1s step-start infinite;
        }

        @keyframes blink {
            50% { opacity: 1; }
        }

         /* --- Touch Controls --- */
        #touch-controls {
            display: none; /* Hidden by default, shown via JS */
            width: 100%; /* Take full width below game */
            max-width: 600px; /* Match game container width */
            margin-top: 15px; /* Space above controls */
            padding: 0 10px; /* Padding on sides */
            box-sizing: border-box;
            justify-content: space-between; /* Space out buttons */
            align-items: center; /* Vertically align */
        }

        #touch-controls button {
            background-color: rgba(0, 255, 0, 0.3); /* Semi-transparent green */
            border: 2px solid #0f0;
            color: #0f0;
            font-family: 'Courier New', Courier, monospace;
            font-size: 24px; /* Larger for touch */
            font-weight: bold;
            padding: 15px 20px; /* Generous padding */
            border-radius: 8px; /* Rounded corners */
            cursor: pointer; /* Indicate interactivity */
            touch-action: manipulation; /* Improve touch responsiveness */
            flex-grow: 1; /* Allow buttons to grow */
            margin: 0 5px; /* Space between buttons */
            text-align: center;
            min-width: 60px; /* Minimum width */
        }

        #touch-controls button:active {
            background-color: rgba(0, 255, 0, 0.6); /* Darker green when pressed */
        }

        #touch-controls .fire-button {
            /* Optional: Make fire button slightly different */
            /* background-color: rgba(255, 255, 0, 0.3); */
            /* border-color: #ff0; */
            /* color: #ff0; */
            min-width: 100px; /* Make fire button wider */
            flex-grow: 1.5; /* Make it slightly larger */
        }

    </style>
</head>
<body>
    <div id="game-wrapper">
        <h1>Core Defender <span class="cursor"></span></h1>
        <div id="game-container">
            <div id="hud">
                 <div class="hud-group">
                     <span id="score">SCORE: 0</span>
                     <span id="wave">WAVE: 1</span>
                 </div>
                 <div class="hud-group">
                     <span id="hull">HULL: 100%</span>
                     <span id="heat">HEAT: 0%</span>
                     <span id="lives">LIVES: 3</span>
                 </div>
            </div>
            <canvas id="game-canvas" width="600" height="400"></canvas>
            <div id="management-screen">
                <h2>SYSTEM MANAGEMENT <span class="cursor"></span></h2>
                <div class="status-readout">
                     <span id="man-hull">HULL: 100%</span>
                     <span id="man-heat">HEAT: 0%</span>
                </div>
                <p>ALLOCATE REACTOR POWER (TOTAL: 100%)</p>
                <div class="control-group">
                    <label for="weapon-power">WEAPONS:</label>
                    <input type="range" id="weapon-power" name="weapon-power" min="0" max="100" value="30" step="5">
                    <span class="power-value" id="weapon-power-value">30%</span>
                </div>
                <div class="control-group">
                    <label for="shield-power">SHIELDS:</label>
                     <input type="range" id="shield-power" name="shield-power" min="0" max="100" value="30" step="5">
                     <span class="power-value" id="shield-power-value">30%</span>
                </div>
                 <div class="control-group">
                    <label for="cooling-power">COOLING:</label>
                     <input type="range" id="cooling-power" name="cooling-power" min="0" max="100" value="20" step="5">
                     <span class="power-value" id="cooling-power-value">20%</span>
                </div>
                 <div class="control-group">
                    <label for="repair-power">REPAIR:</label>
                     <input type="range" id="repair-power" name="repair-power" min="0" max="100" value="20" step="5">
                     <span class="power-value" id="repair-power-value">20%</span>
                </div>
                <p id="power-warning" style="color: #f00; display: none;">WARNING: Total power exceeds 100%!</p>
                 <button id="start-wave-button">EXEC_WAVE.BAT</button>
                <p style="margin-top: 10px; font-size: 12px;">// WPN:Fire Rate | SHD:Hits | COOL:Heat Sink | REPAIR:Hull Regen</p>
                <p style="font-size: 12px;">// Adjust power levels and press EXEC_WAVE.BAT to start.</p>
            </div>
        </div>

        <div id="touch-controls">
            <button id="touch-left">&lt;</button>
            <button id="touch-fire" class="fire-button">FIRE</button>
            <button id="touch-right">&gt;</button>
        </div>
    </div> <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>

    <script>
        window.addEventListener('DOMContentLoaded', (event) => {

            // --- DOM Elements ---
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const managementScreen = document.getElementById('management-screen');
            const startWaveButton = document.getElementById('start-wave-button');
            const weaponPowerSlider = document.getElementById('weapon-power');
            const shieldPowerSlider = document.getElementById('shield-power');
            const coolingPowerSlider = document.getElementById('cooling-power');
            const repairPowerSlider = document.getElementById('repair-power');
            const weaponPowerValue = document.getElementById('weapon-power-value');
            const shieldPowerValue = document.getElementById('shield-power-value');
            const coolingPowerValue = document.getElementById('cooling-power-value');
            const repairPowerValue = document.getElementById('repair-power-value');
            const powerWarning = document.getElementById('power-warning');
            const scoreDisplay = document.getElementById('score');
            const livesDisplay = document.getElementById('lives');
            const waveDisplay = document.getElementById('wave');
            const hudHullDisplay = document.getElementById('hull');
            const hudHeatDisplay = document.getElementById('heat');
            const manHullDisplay = document.getElementById('man-hull');
            const manHeatDisplay = document.getElementById('man-heat');
            const touchControlsDiv = document.getElementById('touch-controls'); // Touch controls container
            const touchLeftButton = document.getElementById('touch-left');
            const touchRightButton = document.getElementById('touch-right');
            const touchFireButton = document.getElementById('touch-fire');

            // --- Game State ---
            let gameState = 'MANAGEMENT'; // Initial state
            let score = 0;
            let lives = 3;
            let wave = 1;
            let player;
            let bullets = [];
            let enemies = [];
            let keys = {}; // Still keep track of keyboard keys
            let capturedPlayer = null;
            let particles = [];

            // --- Touch Control State ---
            let touchLeftActive = false;
            let touchRightActive = false;
            let touchFireActive = false;

            // --- Power Allocation ---
            let weaponPower = 30;
            let shieldPower = 30;
            let coolingPower = 20;
            let repairPower = 20;

            // --- Management Screen Focus ---
            const focusableControls = [weaponPowerSlider, shieldPowerSlider, coolingPowerSlider, repairPowerSlider, startWaveButton];
            let focusedControlIndex = 0;

            // --- Game Settings ---
            const playerWidth = 30;
            const playerHeight = 20;
            const enemyWidth = 30;
            const enemyHeight = 20;
            const playerSpeed = 5;
            const bulletWidth = 4;
            const bulletHeight = 8;
            const bulletRadius = 3;
            const bulletSpeedBase = 5;
            const fireRateCooldownBase = 30; // Lower is faster base rate
            const enemySpacing = 40;
            const sliderStep = 5; // Step for keyboard adjustment

            // --- Hull & Heat Settings ---
            const maxHullIntegrity = 100;
            const maxHeat = 100;
            const heatGenerationPerShot = 2;
            const baseHeatDissipation = 0.1;
            const coolingPowerFactor = 0.005;
            const overheatThreshold = 85;
            const overheatCooldown = 60; // Frames weapon is disabled
            const repairPowerFactor = 0.2; // Hull points repaired per % power * wave

            // --- Difficulty Settings ---
            const enemySpeedBase = 0.5;
            const enemySpeedIncrease = 0.1;
            const maxEnemySpeed = 3;
            const startEnemyRows = 1;
            const startEnemiesPerRow = 4;
            const maxEnemyRows = 3;
            const maxEnemiesPerRow = 8;
            const rowsIncreaseInterval = 2;
            const perRowIncreaseInterval = 1;

            // --- Current Wave Difficulty ---
            let currentEnemySpeed = enemySpeedBase;
            let currentEnemyRows = startEnemyRows;
            let currentEnemiesPerRow = startEnemiesPerRow;

            // --- Enemy Specific Settings ---
            const DIVE_TRIGGER_Y = 100;
            const DIVE_PREP_TIME = 45;
            const DIVE_SPEED_FACTOR = 2.5;
            const DIVE_HORIZONTAL_SPEED = 2;
            const TRACTOR_TRIGGER_Y = 100;
            const TRACTOR_PREP_TIME = 60;
            const TRACTOR_BEAM_SPEED = 3;
            const TRACTOR_BEAM_MAX_LENGTH = 300;
            const TRACTOR_BEAM_WIDTH = 30;
            const CAPTURE_RETURN_SPEED = 2;

            // --- Particle Settings ---
            const PARTICLE_COUNT = 8;
            const PARTICLE_SPEED_RANGE = { min: 1, max: 3 };
            const PARTICLE_LIFE_RANGE = { min: 20, max: 40 };
            const PARTICLE_SIZE_RANGE = { min: 2, max: 4 };

            // --- Audio Setup ---
            let audioInitialized = false;
            let laserSynth, explosionSynth, damageSynth, uiSynth, specialSynth, overheatSynth;
            let bassSynth, bassSequence;

            function initializeAudio() {
                if (typeof Tone === 'undefined') { console.error("Tone.js is not loaded yet!"); return; }
                if (audioInitialized) return;
                // Use a user interaction event (like the first touch/click) to start audio context
                Tone.start().then(() => {
                    console.log("Audio Context Started");
                    laserSynth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 }, volume: -12 }).toDestination();
                    explosionSynth = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 5, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.4 }, volume: -8 }).toDestination();
                    uiSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.05, sustain: 0, release: 0.1 }, volume: -18 }).toDestination();
                    specialSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 }, volume: -10 }).toDestination();
                    damageSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'square' }, envelope: { attack: 0.02, decay: 0.3, sustain: 0, release: 0.1 }, volume: -10 }).toDestination();
                    overheatSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.1, decay: 0.2, sustain: 0, release: 0.1 }, volume: -8 }).toDestination(); // Warning sound
                    bassSynth = new Tone.MonoSynth({ oscillator: { type: "square" }, filter: { Q: 2, type: "lowpass", rolloff: -12 }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.4, release: 0.5 }, filterEnvelope: { attack: 0.01, decay: 0.1, sustain: 0.8, release: 0.5, baseFrequency: 100, octaves: 4 }, volume: -18 }).toDestination();
                    const bassNotes = ["C2", null, "G2", null, "Eb2", null, "G2", "Bb1"];
                    bassSequence = new Tone.Sequence((time, note) => { if (note) { bassSynth.triggerAttackRelease(note, "8n", time); } }, bassNotes, "8n");
                    bassSequence.loop = true;
                    bassSequence.start(0);
                    Tone.Transport.bpm.value = 100;
                    audioInitialized = true;
                    console.log("Audio Initialized Successfully");
                }).catch(e => { console.error("Error starting Tone.js Audio Context:", e); });
            }

            // --- Particle Class ---
            class Particle {
                constructor(x, y, color) {
                    this.x = x;
                    this.y = y;
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * (PARTICLE_SPEED_RANGE.max - PARTICLE_SPEED_RANGE.min) + PARTICLE_SPEED_RANGE.min;
                    this.vx = Math.cos(angle) * speed;
                    this.vy = Math.sin(angle) * speed;
                    this.size = Math.random() * (PARTICLE_SIZE_RANGE.max - PARTICLE_SIZE_RANGE.min) + PARTICLE_SIZE_RANGE.min;
                    this.maxLife = Math.random() * (PARTICLE_LIFE_RANGE.max - PARTICLE_LIFE_RANGE.min) + PARTICLE_LIFE_RANGE.min;
                    this.life = this.maxLife;
                    // Slightly adjusted particle colors for visibility
                    this.color = (Math.random() < 0.1) ? '#fff' : (Math.random() < 0.1 ? '#ff0' : color);
                }
                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.life--;
                }
                draw() {
                    // Use save/restore for globalAlpha changes
                    ctx.save();
                    ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
                    ctx.restore(); // Restore alpha
                }
            }
            function createExplosion(x, y, color) {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    particles.push(new Particle(x, y, color));
                }
            }

            // --- Player Class ---
            class Player {
                constructor(x, y, width, height, color) {
                    this.x = x;
                    this.y = y;
                    this.width = width;
                    this.height = height;
                    this.color = color;
                    this.fireCooldown = 0;
                    this.isCaptured = false;
                    this.isOverheated = false;
                    this.hullIntegrity = maxHullIntegrity; // Start with full hull
                    this.heat = 0; // Start with zero heat
                    this.updateMaxHits();
                    this.currentHits = this.maxHits;
                }
                updateMaxHits() {
                    this.maxHits = 1 + Math.floor(shieldPower / 50);
                    this.currentHits = Math.min(this.currentHits, this.maxHits);
                }
                draw() {
                    const centerX = this.x + this.width / 2;
                    const centerY = this.y + this.height / 2;
                    // Draw shield
                    if (!this.isCaptured) {
                        const shieldOpacityFactor = this.maxHits > 0 ? (this.currentHits / this.maxHits) : 0;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, this.width * 0.75, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(0, 255, 255, ${0.15 + 0.3 * shieldOpacityFactor})`;
                        ctx.fill();
                        ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + 0.5 * shieldOpacityFactor})`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                    // Draw ship body - Tint red if overheated
                    ctx.fillStyle = this.isOverheated ? '#f55' : '#0f0'; // Use main color or red tint
                    ctx.beginPath();
                    ctx.moveTo(centerX, this.y); // Nose
                    ctx.lineTo(this.x + this.width, this.y + this.height * 0.8); // Right wingtip back
                    ctx.lineTo(centerX + this.width * 0.2, this.y + this.height * 0.7); // Right inner engine indent
                    ctx.lineTo(centerX + this.width * 0.2, this.y + this.height); // Right engine back
                    ctx.lineTo(centerX - this.width * 0.2, this.y + this.height); // Left engine back
                    ctx.lineTo(centerX - this.width * 0.2, this.y + this.height * 0.7); // Left inner engine indent
                    ctx.lineTo(this.x, this.y + this.height * 0.8); // Left wingtip back
                    ctx.closePath();
                    ctx.fill();
                    // Details
                    ctx.fillStyle = '#fff'; // Cockpit
                    ctx.beginPath();
                    ctx.moveTo(centerX, this.y + this.height * 0.1);
                    ctx.lineTo(centerX + this.width * 0.1, this.y + this.height * 0.3);
                    ctx.lineTo(centerX, this.y + this.height * 0.4);
                    ctx.lineTo(centerX - this.width * 0.1, this.y + this.height * 0.3);
                    ctx.closePath();
                    ctx.fill();
                    // Engine glow (subtle)
                    ctx.fillStyle = '#aaa';
                    ctx.fillRect(centerX + this.width * 0.2 - 2, this.y + this.height - 2, 4, 4);
                    ctx.fillRect(centerX - this.width * 0.2 - 2, this.y + this.height - 2, 4, 4);
                }
                update() {
                    if (this.isCaptured) return;

                    // --- Movement --- Check both keyboard AND touch controls
                    if ((keys['ArrowLeft'] || touchLeftActive) && this.x > 0) {
                        this.x -= playerSpeed;
                    }
                    if ((keys['ArrowRight'] || touchRightActive) && this.x < canvas.width - this.width) {
                        this.x += playerSpeed;
                    }

                    // Heat Dissipation
                    const dissipationAmount = baseHeatDissipation + (coolingPower * coolingPowerFactor);
                    this.heat = Math.max(0, this.heat - dissipationAmount);

                    // Overheat Check
                    if (this.isOverheated) {
                        if (this.heat < overheatThreshold * 0.5) { // Cooldown condition
                            this.isOverheated = false;
                        } else {
                            this.fireCooldown = Math.max(this.fireCooldown, 2); // Keep weapon disabled
                        }
                    } else {
                        if (this.heat >= maxHeat) {
                            console.log("Overheated!");
                            this.isOverheated = true;
                            if (audioInitialized) overheatSynth.triggerAttackRelease("A3", "4n", Tone.now());
                            this.fireCooldown = overheatCooldown; // Disable weapon for a duration
                        }
                    }

                    // Shooting Cooldown
                    if (this.fireCooldown > 0) this.fireCooldown--;

                    // --- Shooting Attempt --- Check both keyboard AND touch controls
                    if (!this.isOverheated && (keys[' '] || touchFireActive) && this.fireCooldown === 0) {
                        this.shoot();
                        const effectiveCooldown = fireRateCooldownBase / (1 + (weaponPower / 50));
                        this.fireCooldown = Math.max(5, Math.floor(effectiveCooldown)); // Ensure minimum cooldown
                    }
                    updateHUD(); // Update HUD frequently
                }
                shoot() {
                    const effectiveBulletSpeed = bulletSpeedBase * (1 + (weaponPower / 100));
                    bullets.push(new Bullet(this.x + this.width / 2, this.y, bulletWidth, bulletHeight, '#ff0', effectiveBulletSpeed));
                    this.heat = Math.min(maxHeat, this.heat + heatGenerationPerShot);
                    if (audioInitialized) laserSynth.triggerAttackRelease("G5", "32n", Tone.now());
                }
                hit() {
                    if (this.isCaptured) return;
                    if (audioInitialized) damageSynth.triggerAttackRelease("C3", "8n", Tone.now());

                    if (this.currentHits > 0) {
                        this.currentHits--; // Damage shield first
                    } else if (this.hullIntegrity > 0) {
                        this.hullIntegrity -= 10; // Damage hull
                        this.hullIntegrity = Math.max(0, this.hullIntegrity); // Clamp at 0
                        console.log("Hull hit! Integrity:", this.hullIntegrity);
                        if (this.hullIntegrity <= 0) {
                            handlePlayerDeath();
                        }
                    }
                }
            }

            // --- Bullet Class ---
            class Bullet {
                constructor(x, y, width, height, color, speed) {
                    this.x = x;
                    this.y = y;
                    this.width = width;
                    this.height = height;
                    this.radius = bulletRadius;
                    this.color = color;
                    this.speed = speed;
                }
                draw() {
                    // Simple circle bullet
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                    // Optional inner highlight
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 0.5, 0, Math.PI * 2);
                    ctx.fillStyle = '#fff';
                    ctx.fill();
                }
                update() {
                    this.y -= this.speed;
                }
            }

            // --- Enemy Class ---
            class Enemy {
                constructor(x, y, width, height, color, type = 'STANDARD') {
                    this.x = x;
                    this.y = y;
                    this.width = width;
                    this.height = height;
                    this.baseColor = color;
                    this.color = color; // Current color (for flashing)
                    this.type = type;
                    this.state = 'FORMATION'; // FORMATION, PRE_TRACTOR, TRACTOR_ACTIVE, CAPTURING, PRE_DIVE, DIVING
                    this.diveTimer = 0;
                    this.diveTargetX = 0;
                    this.tractorTimer = 0;
                    this.isTractorBeamActive = false;
                    this.tractorBeamLength = 0;
                    this.capturedShip = null;
                    this.remove = false; // Flag for removal
                }
                draw() {
                    const centerX = this.x + this.width / 2;
                    const centerY = this.y + this.height / 2;
                    ctx.fillStyle = this.color; // Use current color

                    // Draw based on type
                    if (this.type === 'STANDARD') {
                        // Simple oval shape
                        ctx.beginPath();
                        ctx.ellipse(centerX, centerY, this.width * 0.4, this.height * 0.5, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Small side pods
                        ctx.fillRect(this.x, centerY - 3, 6, 6);
                        ctx.fillRect(this.x + this.width - 6, centerY - 3, 6, 6);
                        // Cockpit dot
                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.arc(centerX, centerY - this.height * 0.1, 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else { // DIVER / TRACTOR type
                        // More angular shape
                        ctx.beginPath();
                        ctx.moveTo(centerX, this.y); // Nose
                        ctx.lineTo(this.x + this.width, centerY); // Right wingtip
                        ctx.lineTo(centerX + this.width * 0.2, this.y + this.height); // Right back corner
                        ctx.lineTo(centerX - this.width * 0.2, this.y + this.height); // Left back corner
                        ctx.lineTo(this.x, centerY); // Left wingtip
                        ctx.closePath();
                        ctx.fill();
                        // Eye/Sensor
                        ctx.fillStyle = '#ff0'; // Yellow eye
                        ctx.beginPath();
                        ctx.arc(centerX, centerY + this.height * 0.1, 2.5, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Draw Tractor Beam if active
                    if (this.isTractorBeamActive) {
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y + this.height); // Bottom left
                        ctx.lineTo(this.x + this.width, this.y + this.height); // Bottom right
                        ctx.lineTo(centerX + TRACTOR_BEAM_WIDTH / 2, this.y + this.height + this.tractorBeamLength); // Tip right
                        ctx.lineTo(centerX - TRACTOR_BEAM_WIDTH / 2, this.y + this.height + this.tractorBeamLength); // Tip left
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(0, 150, 255, 0.3)'; // Semi-transparent blue fill
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)'; // Light blue outline
                        ctx.stroke();
                    }

                    // Draw captured ship if it exists
                    if (this.capturedShip) {
                        this.capturedShip.draw();
                    }
                }
                update() {
                    let originalColor = this.baseColor; // Store base color

                    // --- Movement and State Logic ---
                    if (this.type === 'STANDARD') {
                        this.y += currentEnemySpeed;
                    } else if (this.type === 'DIVER') { // Combined Tractor/Diver logic
                        switch (this.state) {
                            case 'FORMATION':
                                this.y += currentEnemySpeed;
                                // Check if it should start tractor beam behavior
                                if (this.y >= TRACTOR_TRIGGER_Y && !this.isTractorBeamActive && !this.capturedShip) {
                                    this.state = 'PRE_TRACTOR';
                                    this.tractorTimer = TRACTOR_PREP_TIME;
                                    this.color = '#00f'; // Flash blue
                                    if (audioInitialized) specialSynth.triggerAttackRelease("A4", "16n", Tone.now());
                                }
                                break;
                            case 'PRE_TRACTOR':
                                this.tractorTimer--;
                                // Slight wobble
                                this.x += Math.sin(this.tractorTimer * 0.6) * 0.6;
                                if (this.tractorTimer <= 0) {
                                    this.state = 'TRACTOR_ACTIVE';
                                    this.color = originalColor; // Back to normal color
                                    this.isTractorBeamActive = true;
                                    this.tractorBeamLength = 0;
                                }
                                break;
                            case 'TRACTOR_ACTIVE':
                                this.tractorBeamLength += TRACTOR_BEAM_SPEED;
                                // Check if beam reached max length or captured player
                                if (this.tractorBeamLength >= TRACTOR_BEAM_MAX_LENGTH || this.capturedShip) {
                                    this.isTractorBeamActive = false;
                                    if (!this.capturedShip) { // If didn't capture, prepare to dive
                                        this.state = 'PRE_DIVE';
                                        this.diveTimer = DIVE_PREP_TIME;
                                        this.color = '#ff0'; // Flash yellow
                                        if (audioInitialized) specialSynth.triggerAttackRelease("G4", "16n", Tone.now());
                                    } else { // If captured, state remains CAPTURING (set in handlePlayerCapture)
                                        this.state = 'CAPTURING';
                                    }
                                }
                                break;
                            case 'CAPTURING':
                                // Move upwards off screen with the captured ship
                                this.y -= CAPTURE_RETURN_SPEED;
                                if (this.capturedShip) {
                                    // Keep captured ship positioned relative to enemy
                                    this.capturedShip.x = this.x + this.width / 2 - this.capturedShip.width / 2;
                                    this.capturedShip.y = this.y + this.height + 5;
                                }
                                // Check if off-screen
                                if (this.y + this.height < 0) {
                                    this.remove = true;
                                    // Important: Nullify the global captured player reference if this enemy escapes
                                    if (this.capturedShip === capturedPlayer) {
                                        capturedPlayer = null;
                                    }
                                }
                                break;
                            case 'PRE_DIVE':
                                this.diveTimer--;
                                // Slight wobble
                                this.x += Math.sin(this.diveTimer * 0.5) * 0.5;
                                if (this.diveTimer <= 0) {
                                    this.state = 'DIVING';
                                    this.color = originalColor; // Back to normal color
                                    // Target the player's current position when dive starts
                                    if (player && !player.isCaptured) this.diveTargetX = player.x + player.width / 2;
                                    else this.diveTargetX = this.x; // Or dive straight down if no player
                                }
                                break;
                            case 'DIVING':
                                // Move down faster
                                this.y += currentEnemySpeed * DIVE_SPEED_FACTOR;
                                // Move horizontally towards target
                                if (Math.abs(this.x - this.diveTargetX) > DIVE_HORIZONTAL_SPEED) {
                                    this.x += Math.sign(this.diveTargetX - this.x) * DIVE_HORIZONTAL_SPEED;
                                }
                                break;
                        }
                    }

                    // Reset color if not in a flashing state
                    if (this.state !== 'PRE_TRACTOR' && this.state !== 'PRE_DIVE') {
                        this.color = this.baseColor;
                    }

                    // Check if off-screen (bottom) and not currently capturing
                    if (this.y > canvas.height && this.state !== 'CAPTURING') {
                        this.remove = true;
                        // If a standard enemy reaches the bottom, game over (or lose life?) - Let's make it game over for now.
                        if (this.type === 'STANDARD' && gameState === 'ACTION') {
                            console.log("Enemy reached bottom!");
                            lives = 0; // Instant game over if standard enemy passes
                            gameState = 'GAMEOVER';
                        }
                    }
                } // End of update()
            } // End of Enemy Class

            // --- Game Functions ---
            function calculateDifficulty() {
                currentEnemySpeed = Math.min(maxEnemySpeed, enemySpeedBase + (wave - 1) * enemySpeedIncrease);
                currentEnemyRows = Math.min(maxEnemyRows, startEnemyRows + Math.floor((wave - 1) / rowsIncreaseInterval));
                currentEnemiesPerRow = Math.min(maxEnemiesPerRow, startEnemiesPerRow + Math.floor((wave - 1) / perRowIncreaseInterval));
                console.log(`Wave ${wave}: Speed=${currentEnemySpeed.toFixed(1)}, Rows=${currentEnemyRows}, PerRow=${currentEnemiesPerRow}`);
            }
            function spawnEnemies() {
                enemies = [];
                const totalWidth = currentEnemiesPerRow * enemySpacing;
                const startX = (canvas.width - totalWidth) / 2 + enemySpacing / 2 - enemyWidth / 2; // Centered start X
                const startY = 50; // Initial Y position

                for (let r = 0; r < currentEnemyRows; r++) {
                    for (let c = 0; c < currentEnemiesPerRow; c++) {
                        const x = startX + c * enemySpacing;
                        const y = startY + r * enemySpacing;
                        let type = 'STANDARD';
                        let color = `hsl(${270 + r * 15}, 100%, 50%)`; // Standard color based on row

                        // Make the last row 'DIVER' type
                        if (r === currentEnemyRows - 1) {
                            type = 'DIVER';
                            color = '#f00'; // Red for diver/tractor enemies
                        }
                        enemies.push(new Enemy(x, y, enemyWidth, enemyHeight, color, type));
                    }
                }
            }

            function handlePlayerDeath() {
                lives--;
                updateHUD();
                createExplosion(player.x + player.width / 2, player.y + player.height / 2, '#f00'); // Player explosion

                if (lives > 0) {
                    // Respawn player after a short delay? Or instantly? Instant for now.
                    player = new Player(canvas.width / 2 - playerWidth / 2, canvas.height - 40 - playerHeight / 2, playerWidth, playerHeight, '#0f0');
                    // Hull resets in constructor, heat/shields reset in startGame
                } else {
                    // Game Over
                    if (audioInitialized) specialSynth.triggerAttackRelease("C3", "2n", Tone.now());
                    gameState = 'GAMEOVER';
                    if (audioInitialized && Tone.Transport.state === 'started') {
                        Tone.Transport.stop();
                        Tone.Transport.cancel();
                        console.log("Music stopped (Game Over)");
                    }
                    player = null; // Remove player object
                    updateControlVisibility(); // Hide touch controls on game over
                }
            }
            function handlePlayerCapture(capturingEnemy) {
                if (!player || player.isCaptured) return; // Can't capture if already captured or no player

                console.log("Player captured!");
                if (audioInitialized) damageSynth.triggerAttackRelease("E3", "4n", Tone.now());
                player.isCaptured = true;
                capturedPlayer = player; // Store reference to the captured player globally
                capturingEnemy.capturedShip = player; // Link player to the enemy
                capturingEnemy.state = 'CAPTURING'; // Set enemy state
                capturingEnemy.isTractorBeamActive = false; // Turn off beam

                // Player loses a life when captured
                handlePlayerDeath();
            }

            function updateGameObjects() {
                if (player && !player.isCaptured) player.update();

                // Update Bullets
                for (let i = bullets.length - 1; i >= 0; i--) {
                    bullets[i].update();
                    if (bullets[i].y < 0) {
                        bullets.splice(i, 1); // Remove if off-screen
                    }
                }

                // Update Enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    enemies[i].update();
                    // If enemy is capturing, update the captured ship's position visually
                    if (enemies[i].state === 'CAPTURING' && enemies[i].capturedShip) {
                        enemies[i].capturedShip.x = enemies[i].x + enemies[i].width / 2 - enemies[i].capturedShip.width / 2;
                        enemies[i].capturedShip.y = enemies[i].y + enemies[i].height + 5;
                    }
                    // Remove enemies flagged for removal (off-screen)
                    if (enemies[i].remove) {
                        // If the removed enemy was capturing the global player, clear the global reference
                        if (enemies[i].state === 'CAPTURING' && enemies[i].capturedShip === capturedPlayer) {
                            capturedPlayer = null;
                        }
                        enemies.splice(i, 1);
                    }
                }

                // Update Particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    particles[i].update();
                    if (particles[i].life <= 0) {
                        particles.splice(i, 1); // Remove dead particles
                    }
                }

                checkCollisions();

                // Check for wave end condition
                if (enemies.length === 0 && gameState === 'ACTION') {
                    wave++;
                    gameState = 'MANAGEMENT';
                    showManagementScreen(); // Go back to management screen
                }
            }
            function drawGameObjects() {
                // Clear canvas
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw Player (if exists and not captured by an enemy still on screen)
                if (player && (!player.isCaptured || !enemies.some(e => e.capturedShip === player))) {
                     player.draw();
                }
                // Note: Captured player is drawn by the enemy holding it

                // Draw Bullets
                bullets.forEach(bullet => bullet.draw());

                // Draw Enemies (and potentially captured player)
                enemies.forEach(enemy => enemy.draw());

                // Draw Particles
                // Using save/restore within particle draw now
                particles.forEach(particle => particle.draw());
            }
            function checkCollisions() {
                // --- Bullet vs Enemy Collisions ---
                for (let i = bullets.length - 1; i >= 0; i--) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        // Basic AABB collision check (can be improved with radius check)
                        const bullet = bullets[i];
                        const enemy = enemies[j];
                        if (!bullet || !enemy) continue; // Skip if already removed

                        const bulletX = bullet.x;
                        const bulletY = bullet.y;
                        const bulletRadiusCheck = bullet.radius; // Use radius for check

                        // Check collision using bullet center and enemy bounding box
                        if (bulletX > enemy.x && bulletX < enemy.x + enemy.width &&
                            bulletY > enemy.y && bulletY < enemy.y + enemy.height)
                        {
                            createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, enemy.baseColor);
                            if (audioInitialized) explosionSynth.triggerAttackRelease("8n", Tone.now());

                            // --- Check if rescuing captured player ---
                            if (enemy.state === 'CAPTURING' && enemy.capturedShip) {
                                console.log("Captured ship rescued!");
                                // If the rescued ship is the globally captured one, reset global state
                                if (enemy.capturedShip === capturedPlayer) {
                                    capturedPlayer.isCaptured = false; // Mark player as not captured
                                    // Place rescued player back at bottom center (or last known pos?)
                                    capturedPlayer.x = canvas.width / 2 - capturedPlayer.width / 2;
                                    capturedPlayer.y = canvas.height - 40 - capturedPlayer.height / 2;
                                    player = capturedPlayer; // Restore the global player reference
                                    capturedPlayer = null; // Clear the global captured reference
                                }
                                enemy.capturedShip = null; // Remove link from enemy
                                if (audioInitialized) specialSynth.triggerAttackRelease("G5", "8n", Tone.now());
                                // Enemy might still be removed below
                            }

                            enemies.splice(j, 1); // Remove enemy
                            bullets.splice(i, 1); // Remove bullet
                            score += 10;
                            updateHUD();
                            break; // Exit inner loop once bullet hits an enemy
                        }
                    }
                }

                // --- Player vs Enemy Collision ---
                if (player && !player.isCaptured) {
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const enemy = enemies[i];
                        if (!enemy || enemy.state === 'CAPTURING') continue; // Don't collide with capturing enemies

                        // AABB collision check
                        if (player.x < enemy.x + enemy.width &&
                            player.x + player.width > enemy.x &&
                            player.y < enemy.y + enemy.height &&
                            player.y + player.height > enemy.y)
                        {
                            // Player hit the enemy (or vice versa)
                            createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, enemy.baseColor);
                            enemies.splice(i, 1); // Remove the enemy
                            player.hit(); // Player takes damage/loses shield
                            updateHUD();
                            // No break here, player could potentially hit multiple enemies in one frame
                        }
                    }
                }

                // --- Player vs Tractor Beam Collision ---
                if (player && !player.isCaptured) {
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const enemy = enemies[i];
                        if (enemy.isTractorBeamActive) {
                            const beamBaseY = enemy.y + enemy.height;
                            const beamTipY = beamBaseY + enemy.tractorBeamLength;
                            const beamMidX = enemy.x + enemy.width / 2;
                            // Approximate beam shape as a trapezoid/rectangle for collision
                            const beamTipXLeft = beamMidX - TRACTOR_BEAM_WIDTH / 2;
                            const beamTipXRight = beamMidX + TRACTOR_BEAM_WIDTH / 2;
                            const beamBaseXLeft = enemy.x;
                            const beamBaseXRight = enemy.x + enemy.width;

                            // Simple check: Player intersects the beam's vertical range AND horizontal range
                            if (player.y + player.height > beamBaseY && // Player bottom below beam start
                                player.y < beamTipY &&                 // Player top above beam end
                                player.x + player.width > beamTipXLeft && // Player right overlaps beam left
                                player.x < beamTipXRight)                 // Player left overlaps beam right
                            {
                                handlePlayerCapture(enemy);
                                break; // Only one enemy can capture at a time
                            }
                        }
                    }
                }
            } // End checkCollisions

            function updateHUD() {
                scoreDisplay.textContent = `SCORE: ${score}`;
                livesDisplay.textContent = `LIVES: ${lives}`;
                waveDisplay.textContent = `WAVE: ${wave}`;
                // Update Hull and Heat on HUD if player exists
                if (player) {
                    hudHullDisplay.textContent = `HULL: ${player.hullIntegrity}%`;
                    const heatPercent = Math.min(100, Math.floor((player.heat / maxHeat) * 100));
                    hudHeatDisplay.textContent = `HEAT: ${heatPercent}%`;
                    hudHeatDisplay.style.color = player.isOverheated ? '#f00' : '#0f0'; // Red when overheated
                } else {
                    hudHullDisplay.textContent = `HULL: 0%`;
                    hudHeatDisplay.textContent = `HEAT: 0%`;
                    hudHeatDisplay.style.color = '#0f0';
                }
            }

            // --- Management Screen Specific Functions ---
            function updateFocusVisuals() {
                focusableControls.forEach((control, index) => {
                    if (index === focusedControlIndex) {
                        control.classList.add('focused-control');
                    } else {
                        control.classList.remove('focused-control');
                    }
                });
            }
            function showManagementScreen() {
                gameState = 'MANAGEMENT';
                canvas.style.display = 'none'; // Hide canvas
                managementScreen.style.display = 'block'; // Show management
                updateControlVisibility(); // Hide touch controls

                // Update displays with current player status
                if (player) {
                    manHullDisplay.textContent = `HULL: ${player.hullIntegrity}%`;
                    manHeatDisplay.textContent = `HEAT: ${Math.floor(player.heat)}%`;
                } else { // Handle case where player is null (e.g., after game over)
                    manHullDisplay.textContent = `HULL: ---`;
                    manHeatDisplay.textContent = `HEAT: ---`;
                }
                updateHUD(); // Update main HUD too

                // Set sliders to current power levels
                weaponPowerSlider.value = weaponPower;
                shieldPowerSlider.value = shieldPower;
                coolingPowerSlider.value = coolingPower;
                repairPowerSlider.value = repairPower;
                // Update text displays for sliders
                weaponPowerValue.textContent = `${weaponPower}%`;
                shieldPowerValue.textContent = `${shieldPower}%`;
                coolingPowerValue.textContent = `${coolingPower}%`;
                repairPowerValue.textContent = `${repairPower}%`;

                checkPowerAllocation(); // Check initial allocation and enable/disable button
                focusedControlIndex = 0; // Reset focus to first slider
                updateFocusVisuals();

                // Stop game music if playing
                if (audioInitialized && Tone.Transport.state === 'started') {
                    Tone.Transport.stop();
                    Tone.Transport.cancel();
                    console.log("Music stopped (Management)");
                }
            }
            function checkPowerAllocation() {
                // Read values directly from sliders
                const wp = parseInt(weaponPowerSlider.value);
                const sp = parseInt(shieldPowerSlider.value);
                const cp = parseInt(coolingPowerSlider.value);
                const rp = parseInt(repairPowerSlider.value);
                const totalPower = wp + sp + cp + rp;

                // Update global power variables
                weaponPower = wp;
                shieldPower = sp;
                coolingPower = cp;
                repairPower = rp;

                // Update text displays next to sliders
                weaponPowerValue.textContent = `${wp}%`;
                shieldPowerValue.textContent = `${sp}%`;
                coolingPowerValue.textContent = `${cp}%`;
                repairPowerValue.textContent = `${rp}%`;

                // Check limit and update warning/button state
                const isOverLimit = totalPower > 100;
                powerWarning.style.display = isOverLimit ? 'block' : 'none';
                startWaveButton.disabled = isOverLimit;
                // Style updates handled by CSS :disabled selector now

                return !isOverLimit; // Return true if allocation is valid
            }

            // --- Control Visibility ---
            function updateControlVisibility() {
                if (gameState === 'ACTION') {
                    touchControlsDiv.style.display = 'flex'; // Use flex to show controls
                } else {
                    touchControlsDiv.style.display = 'none'; // Hide controls
                }
            }


            // --- Game Start and Over ---
            function startGame() {
                // Attempt to initialize audio if not already done (requires user interaction)
                if (!audioInitialized && typeof Tone !== 'undefined') {
                    initializeAudio();
                } else if (typeof Tone === 'undefined') {
                    console.warn("Tone.js not ready yet, cannot initialize audio.");
                }

                // --- Apply Repairs Before Starting Wave ---
                if (player) {
                    const hullToRepair = Math.floor(repairPower * repairPowerFactor);
                    player.hullIntegrity = Math.min(maxHullIntegrity, player.hullIntegrity + hullToRepair);
                    console.log(`Repaired ${hullToRepair} hull. Current: ${player.hullIntegrity}`);
                }
                // --- End Apply Repairs ---

                canvas.style.display = 'block'; // Show canvas
                managementScreen.style.display = 'none'; // Hide management
                gameState = 'ACTION';
                updateControlVisibility(); // Show touch controls
                calculateDifficulty(); // Set difficulty for the upcoming wave

                // Reset player state or create new player if needed
                if (lives <= 0) { // If game over previously
                    capturedPlayer = null; // Ensure no lingering captured state
                    score = 0;
                    lives = 3;
                    wave = 1; // Reset wave too? Yes.
                    calculateDifficulty(); // Recalculate for wave 1
                    player = new Player(canvas.width / 2 - playerWidth / 2, canvas.height - 40 - playerHeight / 2, playerWidth, playerHeight, '#0f0');
                } else if (!player) { // If starting for the first time
                     player = new Player(canvas.width / 2 - playerWidth / 2, canvas.height - 40 - playerHeight / 2, playerWidth, playerHeight, '#0f0');
                } else { // Continuing from previous wave
                    player.isCaptured = false; // Ensure not captured
                    // Reposition player
                    player.x = canvas.width / 2 - playerWidth / 2;
                    player.y = canvas.height - 40 - playerHeight / 2;
                }

                // Reset dynamic player stats for the new wave
                player.heat = 0;
                player.isOverheated = false;
                player.updateMaxHits(); // Update max shields based on power allocation
                player.currentHits = player.maxHits; // Reset current shields to max

                // Clear game objects
                bullets = [];
                particles = [];
                enemies = [];
                spawnEnemies(); // Spawn enemies for the new wave
                updateHUD(); // Update display

                // Start game music if initialized and not already playing
                if (audioInitialized && Tone.Transport.state !== 'started') {
                    Tone.Transport.start();
                    console.log("Music started");
                }
                // Play start wave jingle
                if (audioInitialized) {
                    const now = Tone.now();
                    specialSynth.triggerAttackRelease("C4", "8n", now + 0.1);
                    specialSynth.triggerAttackRelease("E4", "8n", now + 0.2);
                    specialSynth.triggerAttackRelease("G4", "8n", now + 0.3);
                }

                gameLoop(); // Start the animation loop
            }
            function gameOver() {
                // Draw Game Over screen
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; // Semi-transparent overlay
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#f00'; // Red text
                ctx.font = '40px "Courier New", Courier, monospace';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 40);

                ctx.font = '20px "Courier New", Courier, monospace';
                ctx.fillText(`FINAL SCORE: ${score}`, canvas.width / 2, canvas.height / 2 + 0);

                ctx.fillStyle = '#ff0'; // Yellow text
                ctx.fillText('Press Enter or Tap Screen', canvas.width / 2, canvas.height / 2 + 40);
                ctx.fillText('to Play Again', canvas.width / 2, canvas.height / 2 + 65);


                // Ensure music is stopped
                if (audioInitialized && Tone.Transport.state === 'started') {
                    Tone.Transport.stop();
                    Tone.Transport.cancel();
                    console.log("Music stopped (Game Over - Failsafe)");
                }
                updateControlVisibility(); // Ensure touch controls are hidden
            }

            // --- Event Listeners ---

            // Management Screen Sliders (Input event for real-time update)
            weaponPowerSlider.addEventListener('input', () => { focusedControlIndex = 0; updateFocusVisuals(); checkPowerAllocation(); if (audioInitialized) uiSynth.triggerAttackRelease("A5", "32n", Tone.now()); });
            shieldPowerSlider.addEventListener('input', () => { focusedControlIndex = 1; updateFocusVisuals(); checkPowerAllocation(); if (audioInitialized) uiSynth.triggerAttackRelease("A5", "32n", Tone.now()); });
            coolingPowerSlider.addEventListener('input', () => { focusedControlIndex = 2; updateFocusVisuals(); checkPowerAllocation(); if (audioInitialized) uiSynth.triggerAttackRelease("A5", "32n", Tone.now()); });
            repairPowerSlider.addEventListener('input', () => { focusedControlIndex = 3; updateFocusVisuals(); checkPowerAllocation(); if (audioInitialized) uiSynth.triggerAttackRelease("A5", "32n", Tone.now()); });

            // Management Screen Start Button (Click)
            startWaveButton.addEventListener('click', () => {
                if (checkPowerAllocation()) {
                     // Try initializing audio on first "start" click if not already done
                    if (!audioInitialized) initializeAudio();
                    startGame();
                }
            });

            // --- Touch Control Listeners ---
            // Use pointer events for better compatibility across touch/mouse
            function handlePointerDown(event) {
                 // Try initializing audio on first touch if not already done
                if (!audioInitialized) initializeAudio();

                // Prevent default actions like scrolling or text selection
                event.preventDefault();
                const target = event.target;
                if (target === touchLeftButton) touchLeftActive = true;
                else if (target === touchRightButton) touchRightActive = true;
                else if (target === touchFireButton) touchFireActive = true;
                 // Restart game on tap during game over
                else if (gameState === 'GAMEOVER') {
                    showManagementScreen(); // Go back to management to restart
                }
            }

            function handlePointerUp(event) {
                event.preventDefault();
                const target = event.target;
                if (target === touchLeftButton) touchLeftActive = false;
                else if (target === touchRightButton) touchRightActive = false;
                else if (target === touchFireButton) touchFireActive = false;
            }

             function handlePointerLeave(event) {
                 // If the pointer leaves the button area, consider it released
                event.preventDefault();
                const target = event.target;
                 if (target === touchLeftButton) touchLeftActive = false;
                 else if (target === touchRightButton) touchRightActive = false;
                 else if (target === touchFireButton) touchFireActive = false;
             }

            // Attach pointer listeners to the touch control buttons
            touchLeftButton.addEventListener('pointerdown', handlePointerDown);
            touchRightButton.addEventListener('pointerdown', handlePointerDown);
            touchFireButton.addEventListener('pointerdown', handlePointerDown);

            touchLeftButton.addEventListener('pointerup', handlePointerUp);
            touchRightButton.addEventListener('pointerup', handlePointerUp);
            touchFireButton.addEventListener('pointerup', handlePointerUp);

            // Add pointerleave to handle cases where the finger slides off
            touchLeftButton.addEventListener('pointerleave', handlePointerLeave);
            touchRightButton.addEventListener('pointerleave', handlePointerLeave);
            touchFireButton.addEventListener('pointerleave', handlePointerLeave);

             // Add a listener to the canvas or body for restarting on tap during game over
             document.body.addEventListener('pointerdown', (event) => {
                 // Only trigger restart if game is over and the tap wasn't on a control button
                 if (gameState === 'GAMEOVER' && event.target !== touchLeftButton && event.target !== touchRightButton && event.target !== touchFireButton) {
                      if (!audioInitialized) initializeAudio(); // Init audio if needed
                      showManagementScreen();
                 }
             }, true); // Use capture phase to potentially catch taps sooner


            // --- Keyboard Listeners (Kept for Desktop/Debugging) ---
            window.addEventListener('keydown', (e) => {
                // Allow keyboard controls only if player exists and is not captured
                if (player && !player.isCaptured) {
                    keys[e.key] = true;
                } else {
                    // Ensure movement/fire keys are false if player is captured/null
                    keys['ArrowLeft'] = false;
                    keys['ArrowRight'] = false;
                    keys[' '] = false;
                }

                if (gameState === 'ACTION') {
                    if (e.key === ' ') e.preventDefault(); // Prevent spacebar scrolling
                }
                else if (gameState === 'MANAGEMENT') {
                    // Keyboard navigation for management screen
                    e.preventDefault(); // Prevent default browser actions for arrows/enter
                    let handled = false;
                    let playUISound = false;
                    const sliderCount = 4;
                    const buttonIndex = sliderCount;

                    switch (e.key) {
                        case 'ArrowUp':
                            focusedControlIndex = (focusedControlIndex - 1 + focusableControls.length) % focusableControls.length;
                            handled = true; playUISound = true;
                            break;
                        case 'ArrowDown':
                            focusedControlIndex = (focusedControlIndex + 1) % focusableControls.length;
                            handled = true; playUISound = true;
                            break;
                        case 'ArrowLeft':
                            if (focusedControlIndex < sliderCount) { // If focus is on a slider
                                const slider = focusableControls[focusedControlIndex];
                                slider.value = Math.max(parseInt(slider.min), parseInt(slider.value) - sliderStep);
                                checkPowerAllocation(); // Update values and check limit
                                handled = true; playUISound = true;
                            }
                            break;
                        case 'ArrowRight':
                             if (focusedControlIndex < sliderCount) { // If focus is on a slider
                                const slider = focusableControls[focusedControlIndex];
                                slider.value = Math.min(parseInt(slider.max), parseInt(slider.value) + sliderStep);
                                checkPowerAllocation(); // Update values and check limit
                                handled = true; playUISound = true;
                            }
                            break;
                        case 'Enter':
                            if (focusedControlIndex === buttonIndex && checkPowerAllocation()) { // If focus is on button and power is valid
                                 if (!audioInitialized) initializeAudio(); // Init audio if needed
                                startGame();
                                handled = true;
                            } else if (focusedControlIndex < sliderCount) {
                                // Optional: Allow Enter to focus the button from a slider?
                                // focusedControlIndex = buttonIndex;
                                // handled = true; playUISound = true;
                            }
                            break;
                    }
                    if (handled && playUISound && audioInitialized) {
                        uiSynth.triggerAttackRelease(focusedControlIndex === buttonIndex ? "C6" : "A5", "32n", Tone.now());
                    }
                    if (handled) { // Update visual focus if navigation occurred
                        updateFocusVisuals();
                    }
                } else if (gameState === 'GAMEOVER') {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                         if (!audioInitialized) initializeAudio(); // Init audio if needed
                        showManagementScreen(); // Go back to management screen to restart
                    }
                }
            });

            window.addEventListener('keyup', (e) => {
                keys[e.key] = false; // Reset key state on keyup
            });

            // --- Game Loop ---
            let lastTimestamp = 0;
            function gameLoop(timestamp) {
                // Optional: Calculate delta time for frame-rate independent physics (more complex)
                // const deltaTime = (timestamp - lastTimestamp) / 1000; // Time in seconds
                // lastTimestamp = timestamp;

                if (gameState === 'ACTION') {
                    updateGameObjects();
                    drawGameObjects();
                    requestAnimationFrame(gameLoop); // Continue the loop
                } else if (gameState === 'GAMEOVER') {
                    gameOver(); // Draw the game over screen (no update needed)
                    // Stop requesting frames in GAMEOVER state until restart
                }
                // No requestAnimationFrame if in MANAGEMENT state
            }

            // --- Initial Setup ---
            showManagementScreen(); // Start in the management screen

            // --- Responsive Canvas Handling ---
             function resizeCanvas() {
                 const container = document.getElementById('game-container');
                 const containerWidth = container.clientWidth;
                 // Maintain aspect ratio 600:400
                 const newHeight = containerWidth * (400 / 600);
                 container.style.height = `${newHeight}px`;

                 // You might need to adjust internal game scaling if you want elements
                 // to resize within the canvas, but for now, this keeps the container
                 // responsive while the canvas content remains at 600x400 logical pixels.
             }

             window.addEventListener('resize', resizeCanvas);
             resizeCanvas(); // Initial resize


        }); // End of DOMContentLoaded listener
    </script>
</body>
</html>
